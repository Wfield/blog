react 组件更新分为两个阶段：render 阶段和 commit 阶段；因此可以从两个方面来优化组件性能：
### 阻止组件重渲染 rerender
- 对于 class 组件，使用 shouldComponentUpdate 来阻止 render 方法的执行
- 对于函数式组件，**更细粒度的优化渲染**是使用 React.memo 来阻止函数式组件的重复执行
> 所谓更细粒度的优化渲染，是指函数 Child 整体可能用到了 A、B 两个 props，而渲染仅用到了 B，当 A 变化时不会引起 Child 函数重新执行  
> 当使用 React.memo 优化时，需要将 Child 拆分成两个组件
> ```
> Sub1 = React.memo({ A } => ());
> Sub2 = React.memo({ B } => ());
> ```
> 而使用 useMemo
> ```
> Child = (props) => (
>   return useMemo(<Component />, [ B ])
> )
> ```

### 使用 React.memo
- 当父组件传递给子组件的 props 没有实际变更时，在父组件中使用 useCallback、useMemo 来保证传递给子组件的引用类型的 props 没有变化；子组件使用 React.memo 才能阻止重复执行；

### commit 阶段浏览器渲染
1. React.Profiler 的使用
```jsx
<React.Profiler id='index' onRender={callback}>
  <Component />
</React.Profiler>

let commitCounter = 0;
function callback(id, phase, actualTime,baseTime,startTime,commitTime,interactions) {
  commitCounter ++;
  console.log('countRender: ', countRender);
  console.log(id,phase,actualTime,baseTime,startTime,commitTime,interactions);
}
```
使用 React.Profiler 可以知道每一次 commit 浏览器渲染的时间；根据 commitCounter  和 React devtool 可以查看具体的 commit 渲染的火焰图：
![ReactProfiler说明.png](https://github.com/Wfield/blog/blob/main/assets/ReactProfiler%E8%AF%B4%E6%98%8E.png)

根据火焰图，可以知道每次 commit 组件的渲染耗时，以及什么原因导致组件渲染
