## 准备
确定精确的衡量指标: 页面的跳失率(首屏、技术指标), 业务指标: 转化率; 
要采集哪些性能指标?  
怎么埋点采集?  
performance api  

合理的目标, 约束条件, 边际效应?  


### 购物车
第一阶段: 从 1.4s 到 1.2s.    
做了**基础优化**: js 包的大小、动态加载脚本(区分是不是首屏功能)   
成熟的方法, 即 (对于脚本什么时候加载、如何加载依然是复杂的知识)  
1. 优化首屏需要执行的 js 的大小: 使用 webpack-analyzer 优化 js 大小, 通过 tree-shake 的方式  
2. 懒加载非首屏需要使用的 js: 动态导入脚本、动态插入脚本  
3. 懒执行(加载了 js 但不执行; js 的解析、执行比加载更耗时): preload、prefetch、其他 tricks  

第二阶段: 从 1.2s 到 950ms  
做了**中级优化**: 数据预取 (在模版中 fetch 数据, 而不是在 js bundle 中发起首屏数据请求)  
避开了由前端框架造成的耗时, 需要针对具体的业务、使用的框架进行分析  
优化方向: network 请求瀑布流、框架  

第三阶段: ?  
**高级优化**: 不局限于前端, 全链路拉通进行优化，优化前端页面/框架，后端服务器/中间件，内核，图床，等等  


### 下单页  
第一阶段: 从 2.6s 到 2.2s  


第二阶段: 从 2.2s 到 1.7s  
中级优化:   
1. 针对具体的业务, 将地址页与下单页的 js 拆分开, 并在获取模版时判断需要的 js bundle.  
2. 渲染数据的请求依赖安全参数,  提前安全参数获取的时间点, 而不是在发起请求前才去获取安全参数, 需要等到时间.  
3. todo: 对框架的优化  


## 工具
webpack analyzer  
chrome performance  -- event log  
chrome lighthouse  
chrome js profiler  
chrome tracing  


## 思考
目前我对性能优化只有非常基础的了解. 前端性能优化虽然是对前端开发的基本要求之一, 但这并不能说明前端性能优化是一种基础的知识, 相反我认为是一种非常具有难度的知识.   
将页面从 3、4 秒优化到1、2秒可能并不难, 困难的是如何优化到 1s 之内. 对前端开发来说, 这需要非常多的知识. 


## new
+ 原子化 css 对资源大小的影响
+ graphQL 对请求速度的提高, 优点?


### 减小资源大小
通过两次构建(一次将代码打包成 ES6 的语法, 一次将代码打包成 ES5 + legacy code), 将两份构建后的 bundle 都加入到模版中. 浏览器会根据支持情况下载对应的代码;   
结果就是支持 ES6 语法的浏览器下载的代码中不会包涵 legacy code (ES5 语法实现的对ES6 语法的支持), 减小了最终下载的资源的大小.
```
<!-- ES6 的代码，只会被 现代浏览器下载执行 -->
<script type="module" src="/js/main.min.js" ></script>
<!-- ES5 的代码，只会被老版浏览器下载执行 -->
<script nomodule src="/js/main-legacy.min.js" ></script>
```

